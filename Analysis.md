###PROJECT JOURNAL<br />
Time Review<br /><br />
	It's extremely difficult to determine how many hours total I spend on this project.  I worked on the project every week.  Most weeks, I probably met with the group for a total of roughly 20-30 hours, typically 3 7-ish hour sessions, plus maybe 5 or so hours on my own.  One week in there though, the week of LDOC, I think I worked on it for maybe 5 hours total.  That week was one of the main problems for us, and one of the main reasons we didn't finish.
	My primary job on this project was basically designing the backed of the authoring environment.  	I designed the ProjectReader, InstanceManager, and Controller classes which managed dataflow between the editors in the authoring environment, and between the authoring environment and the player.  Details of that dataflow will be discussed later.  The vast majority of my time was spent on this.<br /><br />
	The first two weeks I spent super productively.  Early in the project we decided on the design for InstanceManager, the primary method of data storage in the authoring environment.  I internalized this design well, so I offered to code it up, and everyone agreed.  All the time I spend on InstanceManager was productive, and I'd do it the same way again.  After I finished the IM, I looked at the code that had already been written for something to do before I took on another big project, and found that the authoring environment layout was just kind of a sloppy first draft at the moment, so I decided to clean up the way tabs were created.  This lead to the creation of ProjectReader, which isn't the greatest class I've ever written, but it's certainly an improvement from what we had.  Additionally, it came in handy later when Greg decided to change the way the AE receives information from the backend;  instead of having to root through the code to find what to change, he just changed the code in the methods of ProjectReader which he knew were called by the AE.  Thus the ProjectReader time, which I did immediately after IM, was also productively used.  <br /><br />
	We decided on the Controller structure later than the InstanceManager structure, but there was no down time between me designing the IM and the Controller since I did the ProjectReader in between.  Thus pretty much all my time leading into the first demo was spent very productively.  I'm not sure exactly how long the actual Controller, ProjectReader, or InstanceManager designs took individually, all I know is that I was pretty constantly working on them in the time before the first demo, and that that time was well spent.  There were a couple large refactorings in the middle there, and I redesinged parts of the IM when we decided on the Controller, but all that time made our overall design better, so I'd certainly spend it the same way were I to do the project over.<br /><br />
	After the first demo though, my productivity plummeted.  I was personally invested in the Controller, IM, ProjectReader, dataflow design and once it was finished I was kind of at a loss for what to do.  In theory, Callie was going to do the Level and Map editors, Megan the Wave and Round, Kevin the sprite editors and Player, and the backend their stuff so I wasn't really sure what to start.  This lead to that lull during LDOC week were I took like 3 or 4 days off.  That lost time would have been great to have that last night when we realized we weren't actually going to finish.
	The productive time I spent after the first demo was on a few things.  First, I implemented adding to the game at a specified key, which I'll go into detail about later.  This was an important use of my time and was required for our saving system.  I also spent time pair programming the round editor with Meagan, which even though we got it mostly finished by the end, really wasn't all that productive, since the editor was really a one person job.  Lastly, I threw together the level editor at the end since Callie ran out of time to do it, and that was a pretty good use of time, since I worked efficiently while I was doing that.  In the end though, I got hardly anything done after the second sprint, compared to the amount of time we had.<br /><br />
	Concerning how I managed my code, I used branches and pull requests more than in any of the previous three projects.  I made branches for tasks I wanted to complete, or miscellaneous branches when I didn't know exactly what I wanted to work on.  I committed roughly 5 or 6 times per branch usually, and when I finished a task I pull requested the branch back into master.  Usually, I'd commit for the first time when I was almost finished with the piece I was working on, with just a few things left to do and testing.  The other 4 or so commits were testing or small changes commits, and then I'd pull request back into master after I finished.   <br /><br />
Teamwork <br /><br />
	I really did enjoy working with this team for the most part.  We met often with at least 5 or so people, and had lots of meetings with 8 or 9.  We had maybe a few large group discussions early about planning the project, but after that most of our discussions were between 2 or 3 people on something more specific.  Overall, during the first sprint, I think we worked really productively as a team.<br /><br />
	As I said earlier, I did what's best described as the backend of the AE, plus the level editor and some of the round editor.  Kevin did all the sprite editors, the tile editor, and tags in the front end.  He also improved the aesthetic appeal of the wave editor and designed our splash screen.  Kevin and I designed the layout for our AE together and pair programmed the editor super class, having it extend Tab, and in doing so set up the tab structure.  Callie designed the map editor, and Megan did most of the wave editor and some of the round editor with me.  In the engine team, Greg designed a high score utility and also implemented annotations and also the modifiers tab in the front end.  He also, along with Qian, was responsible for the at least partially functional player we had.  Qian basically led the engine group, taking on that role pretty well.  Michael did collisions, Janan did interactions at those collisions, Sean helped with collisions and did path finding.<br /><br />
	Communication in the team was pretty good most of the time, but lacked at certain critical junctures.  For example, I wasn't aware that the engine team had basically totally stopped making progress because they wanted example data files to test their code.  If I'd known this right away I could have drawn up everything they needed in like an hour and given it to them.  I really wish I had because I think this drop in their productivity due to not having example data is one of the huge reasons we didn't end up finishing our player.  There were warning signs early in that some people didn't come to as many meetings as they should have.  In general, it felt like our team consisted of much less than 10 people throughout, and in retrospect it would have actually been easier if it had, because the people who we didn't produce productive working code were more of a distraction than they were helpful.<br /><br />
	The plan for completing the project to start out with was relatively simple.  I'd handle dataflow, Kevin would do sprite editors, Megan would do wave and round editors, and Callie would do level and map editors.  Our goal was to save data in Map<String, Map<String, Object>> form, such that each “part” of our game was represented by a Map<String, Object>, and each of these parts could be accessed from that larger map via a String key, which was generated when the part was saved.  All references to other parts, something like a tower needing to shoot a projectile, would be stored by key.  For example, if a tower shoots a projectile saved at key “TestGame_Part5.Projectile”, then that string is stored into the tower's “projectile” field.  I'll discuss this design in greater detail later.  In this manner, the engine team knows exactly how to write their code without the AE being finished (or so I thought).  They know they're going to get a Map<String, Map<String, Object>> containing all the data for the game, and can get from the controller the list of keys corresponding to all the levels, towers, projectiles, rounds, etc. that they want.  This was the only interaction between the AE and the backend, which was good.  Our design was capable of allowing them to test before we finished the AE, if only I'd been aware of how dire the need for example data was.  That's something I'd get on top of if I could do this over.<br /><br />
	In the end, Callie finished the map editor on the last day so I ended up doing the level editor, and Megan didn't feel comfortable with her UI skills so she let Kevin do the aesthetic parts of the wave editor.  Other than that people mostly fulfilled their responsibilities in the AE.<br /><br />
Issues<br /><br />
	Individually I managed my code well for the most part, creating branches for each task and using relatively descriptive commit messages.  I'm disappointment to say I didn't use the issues function on gitHub, which seems like it would have been a good idea.  Because of this, it's super hard to quantify “how many issues” I closed.  I did tons of tasks throughout the project, but since I didn't create issues I'm not really sure how I would sub-divide them into individual things.  Looking at the kinds of issues the engine team used, I probably would have written and closed about 15 throughout the project if I'd done them.<br /><br />
	I can talk about one task I completed though, and that was implement adding parts at a key.  The main choice I faced here was how to rework the methods in the controller to both avoid duplicated code and also provide an intuitive way for each editor to add parts to the game.  I ended up writing 6 methods that corresponded to the 3 ways a part could be added to the controller, each with an option to add keyless or with a key.  In retrospect, it's possible this should have been cut down to just 3, all requiring a key.  At the moment, in each class that holds the data for a part before its saved there exists a “myKey” variable which holds the key at which the part corresponding to that UI component is stored.  Again, more on this design later.  This myKey is initialized as Controller.KEY_BEFORE_CREATION in most of the editor classes (Callie might have initialized it as null, her code was different than all the others).  If we could have standardized this initialization, then I could have put the check for whether the key was still KEY_BEFORE_CREATION in the controller methods, and in doing so cut the number down to 3, instead of having the editors perform that check and then decide which method to call.<br /><br />
	After writing the controller methods, I had to decide whether the Controller or the InstanceManager should determine the keys for the parts.  Ultimately, I decided on the InstanceManager doing it, because it made more sense to me; since the InstanceManager basically constitutes the map of storage, it should determine the keys at which things are stored inside of it.  On that same line of thought, if the IM is basically the map of storage, then it doesn't make sence for the IM to parse data like Settings objects into Map<String, Object>'s for saving, so I moved those tasks to the Controller.<br /><br />
	After implementing the new methods and fixing the calls to them in the editors, I pull requested into master.  I should have written an issue beforehand then closed it, something I'll do on the next big project I work on.  The only change to this design we needed to make after I did this was to what keys were generated.  Originally, keys were generated as “[gamename]_[partname].[parttype]”, but this ran into problems when renaming parts, so we swapped out the [partname] for a unique id.  This unique id was something like “Part0”, where the integer was a counter in the InstanceManager that counted all the parts that had ever been created.<br /><br />
Conclusions<br /><br />
	For the most part, other than the problems previously listed our team worked together pretty well.  Since we didn't finish, it's tempting to focus only on the negative aspects of our group effort, but in reality we were mostly a good team.  We SEVERLY underestimated the size of the player.  We didn't have people totally devoted to completing it until the last day, which cost us dearly at the end.<br /><br />
	With regards to the size of the project, it's hard to say exactly what happened.  It was pretty surprising that Callie was only able to finish the Map editor throughout the entire project, which left work for Kevin and me to do which we didn't think we would have to.  In that sense, I guess we underestimated it.  Really though, by the end, even with Callie's less than stellar pace, we did pretty much finish the AE, so our underestimation about the size of the player was really the only thing that went wrong with regards to estimation.  In the future, we just need to set more concrete goals earlier.  If we'd started the player earlier, with a goal of when to finish it, then we would have realized it was bigger than we thought and got a handle on it before we actually ran out of time.<br /><br />
	I took on plenty of responsibility within the team, but I should have taken on more.  Even though I feel like I did my part and more in order to get this project done, I still want to look for things I could have done differently that could have led to a better result.  For one thing, I should have given Megan more work to do.  She could handle it, but isn't the best at taking initiative.  I knew that going in and should have given her concrete tasks to do that she could complete, which would have saved me or Kevin the time.  I could have also written issues for these to make things even more concrete.  I didn't learn until this project that setting goals is actually very important for productivity.  <br /><br />
	In the past, in all projects where I was forced to set goals, like the IDC in ECE110, the goal setting was totally pointless.  On such a tiny project where you have probably 30 times the amount of time you need to finish it, setting goals is just totally unnecessary and extraneous.  The time it takes to write and formalize the goal adds a significant amount of time to the actual completion of it.  For example, spending like 2 hours creating and updating a Gantt chart for tasks that take a total of maybe 6 hours is just a huge waste of time.  Anyway, the point is I learned that in a real project you have to set goals, a valuable lesson I'll carry with me from now on.
	Additionally, I should have been realistic about what Callie was going to finish sooner than I was, and just accepted that I was going to do the level editor.  That way, I would have started it sooner and it would have been better than just functional by the end.<br /><br />
	The control and data flow structure required a lot of editing as we changed the ways we wanted to do things, but all in all it came out pretty well.  I'll refactor some of the things I've thought of since, particularly in the controller, but that was always a work in progress. <br /><br />
	I'm honestly not sure how to be a better designer, since everything I can think of to make the design better I already do.  The best way I think is just to have lots of discussions with other coders and listen to everything they have to say.  That way, I can take the best of what I can design, and mix it with the best of what they have to offer to make something even better.  Specifically, conversations with Qian were great because his ideas are usually things I hadn't thought of before.<br /><br />
	To be a better teammate, I need to do a few things.  First is get more in tuned with how the rest of the project is going at all times.  I should have been asking Qian, who basically led the backend squad, frequently if they needed anything.  That would have fixed the data files problem that halted their productivity for like a week.  Also, I somehow probably need to find a way to get not as frustrated with people.  For example, I spent longer explaining how the Controller worked to Callie than to everyone else combined, and because it took so long a lot of times I raised my voice or got kind of aggressive, which just doesn't help the conversation move forward.  This is something I need to work on in general, and of course it effects me as a teammate as well.<br /><br />
	If I could improve one part of the project, it would be the player.  It would be great to have a working player, since our backend and AE are mostly done independently but we couldn't really see them work together by the end.
<br /><br />
###DESIGN REVIEW 
Status <br /><br />
	The code is generally consistent for the most part.  I used to camel case my constants but we went through and unified all of them to all caps with underscores for consistency's sake.  Most of the code is readable, although some of the UI code isn't.  In general, we were thorough about javadocing to increase readability. <br /><br />
	One current dependency we have right now that I never was able to figure out how to get rid of is how the wave and round editors know what to save into the game.  How do they know what parameters to create and save?  Currently, they just create their parameters name as public final strings at the top of the class, which then need to be used to index into the maps they create to retrieve the data.  The problem was that any new information that could be need from the wave/round editor would need a new user interface to support it, so there's no easy way for the backend to request something and have the UI automatically support it; it's not like simply adding another integer or string parameter to a tower.  The global strings representing the parameter names of certain parameters is one of the worst dependencies still in our code, and I problem I still don't know how to solve.  At least it makes sense to have the InstanceManager decide what the name and part key parameter names are, but as for the other global strings it got a little bit murky as to where the information was coming from.<br /><br />
	I was pleasantly surprised how easy it was to extend the wave editor and create the round editor.  Megan really did a good job with the framework of that class.  Also, it's really easy to create another type of sprite the way Kevin set up SpriteView and SpriteEditor.  Unfortunately the map editor was more difficult to extend, and I wasn't able to use the display of maps in the map editor for the display in the round editor because of the way it was designed.  
	Class review, GameObject:  This class is interesting because I'm not sure whether it's necessary.  The class is basically a data structure for ImageViews that also need to contain a key and name.  It only consists of getters and setters, and one method that generates a map with the name of the object in it.  The getRoot method that returns null is almost certainty pointless.  I think that's there as a placeholder to be overwritten by subclasses, but I'm not really sure why the subclass would have a parameter the super class needs a getter for.  The problem I have with it is that we decided early, unanimously, that we were not going to create front end objects out of our data.  We said we could have a front end tower, or a front end projectile, which just holds data that is going to be passed into the IM, but we weren't going to.  Instead, we were going to have the UI component that collected that data (SpriteView or FlowView for example), pass that data directly to the Controller, and thus to the IM.  This class goes against that design, which is why it feels out of place in the project.  If we had designed each of the classes that collects data to then pass that data to an object that extends GameObject, then I could see this code being quite useful.  It prevents us from having to duplicate myKey variable across our Objects, which would have been good.  The problem is that the data structure itself isn't necessary since the key is the only thing it stores that is necessary for each view that takes data to maintain.  For example, a SpriteView only needs to know the key at which it was stored, so it can add the data it gets at that key.  It doesn't need to know the image or name associated with the object.  If we were going to store those, then we could pass the SpriteView object which extended GameObject around the AE, but as I said earlier, we had decided as a team not to do this at the start of the project.  We decided instead to let the Controller manage date flow between the editors, which I'll talk more about later, and then only pass data and not objects between editors.<br /><br />
	Class review, FlowView: I'll start this review by talking about the getWaveKey() method and getPathKey() method (which I wrote, the only parts of this class I wrote), which are similar to the getRoot method in GameObject.  These methods are the result of a terrible design decision I felt forced to make when I was pressed for time while throwing the round editor together.  I needed to call the methods on FlowView objects, even though those instances we were getting were only present in either a WaveFlowView or a RoundFlowView.  I just threw the methods into the superclass to make it work, with the full knowledge that it broke encapsulation, because a FlowView object does not have a waveKey or pathKey.  I wonder if Callie ran into a similar problem with GameObject, but I'm not sure why she didn't fix it since she was working on that part of the project the entire time.<br /><br />
	The rest of this class does its job very well.  It sets up the box and arrow visuals so that they can be recycled in both the wave editor and the round editor, and also implements the saveWave method, since both of the subclasses use that method.  The code is clean and readable, and other than those two methods I threw in while I was rushing, it's clear why everything that's here is here.<br /><br />
	Class review, BooleanSetting:  BooleanSetting is a nice clean example of what a setting object is.  It's a UI component that takes a type of data and stores it, and then allows that data to be retrieved and ultimately stored.  BooleanSetting has an instance, selected, that is a boolean which stores data the user has entered.  The entire setting package is pretty well designed and could be easily pulled out and used to generate a UI for another project.<br /><br />
Design<br /><br />
	First I'll talk about the back end of the AE in detail, since that was what I primarily worked on.  There are a few core classes at the heart of the AE: Controller, InstanceManager, and Editor.  The InstanceManager is the data storage container for all the parts in our game.  It stores them as  Map<String, Map<String, Object>>.  That second Map<String, Object> is what is referred to as a “part” throughout the AE.  The data is stored as String keys which are parameter names, something like “damage”, or “HP”, and Object data, which is the data corresponding to those parameters.  The outer string key in this map was the key that was used to identify the part in the rest of the AE.  These keys were generated as “[gameName]_[part id].[partType]”.  Adding parts to the instance manager added and updated entries into this large map which contained all the data for the game.<br /><br />
	The Controller managed data flow between all the editors and between each editor and the InstanceManager.  Each editor had its own graphical component that took data from the user and then stored that data via the Controller.  For example, SpriteView's took data from the user and called the Controller's add method to store that data into the InstanceManager.  The SpriteEditor set up the space for those SpriteView's to exist in.  All references to other parts were stored as those parts' keys.  For example, if a tower wanted to store a reference for a projectile in its “projectile” field, it would store the key of the projectile that was chosen.  This way, the backend can key into the map of all the parts and easily create find the data for and create this projectile.<br /><br />
	The Controller also provided methods for any editor to access the copies of the information currently stored in others.  In this way, the user interface for, say, a tower, could display the projectiles that were available to select from.  So the question in designing this was what methods to actually put in the controller.<br /><br />
	The Controller provides a method to give out all the keys of a given part type.  Something like get the keys for all the projectiles, and it gives back a list of those string keys.  The Controller also provides a method that takes a key and gives back a full Map<String, Object> copy of the data of the part stored at that key.  In this way, there will never be a situation where it is impossible for an editor to get the information it needs from the Controller.  However, name and image were needed so frequently that it made sense to provide a direct access to copies of that information, instead of making the editors retrieve the full map of data and then key into it to get the image or name.  That's why the getImageForPart and getNameForPart methods were added.<br /><br />
	The addPart methods are currently overloaded to provide 6 ways to add a part to the game.  This is going to be diluted down to 2 in my masterpiece, and I'll explain this change then.<br /><br />
	At creation, the AE would generate all the folders necessary to house the games information.  This was done by the GameCreator class.  First, a folder with the same name as the game would be created in a location that the user specified (this was never implemented on the UI end).  Next, a .gamefile file would be stored inside that folder.  This was the file that the user would open to either load his game into the player or AE (also never implemented on the UI end).  All InstanceManager objects store the root directory of the game that they manage.  The location of the .gamefile was used to determine that directory upon opening the game.  Also inside the gameName folder were created folders corresponding to each of the part types, where individual xml files corresponding to just that part's Map<String, Object> were saved.  There was also an AllPartsData folder where the IM itself was saved and a ImageData folder where all the images that were needed for the game were saved.  <br /><br />
	Every piece of information that the AE saved was a part.  The most basic parts were the sprites, created by Kevin's SpriteEditor and SpriteView classes.  You needed to build sprites first before the rest of the parts. After building sprites, the next step in the game creation process is to build a wave out of your units.  A wave is simply a list of units and the delay from some arbitrary t=0 of when those units should spawn.  After building a wave you needed to build a map and add paths to it.  Once you had paths on a map, you could build rounds.  A round is similar to a wave, except it contains a list of waves, not units.  A round is a list of waves, and which path they should spawn on at a relative time from t=0.  Something like, round 1 spawns on FlyingPath at t=0, round 2 spawns on walking path at t=1.  Rounds are the last stage of game creation before building actual levels.<br /><br />
	A level is just a list of rounds and a map that these rounds are supposed to be played on.  The nice thing about doing it this way is that any map that contains the same paths that exist in the round will be able to run the round, since the paths are just saved as string references to those paths.  Unfortunately, we never got to implement multiple levels being created into a game.	<br /><br />
	You have a game controller that loads in data file sand populates lists of towers and sprites and enemies etc, basically populates the parameter maps, for those and then once those sprites or game elements are created they're placed on layout.  Once on the layout, a quad tree is used to determine what was colliding with what, and then the function table was used to determine what should happen on those collisions.<br /><br />
	A game in our design is represented by a Map<String, Map<String, Object>>.  At the moment, our game is one level.  This level has references to rounds and to a map, via keys, which also exist in this map.  The rounds have references to waves, and the waves to units, etc.  Unfortunately, we never were able to implement a true playing environment or editor, so at the moment our game is just a level.<br /><br />
	The Controller and IM are designed to provide an easy and intuitive way to store data.  The Controller specifically is supposed to allow the editor windows to save and retrieve data easily.  The image and name get from a key methods were added because they were very frequently needed, but other more specific get methods from the part maps weren't added since they would only be used in one editor, meaning the code makes sense in that editor, and not in the Controller.  The only real assumption that the code makes is that the editors know how to use the constants in the InstanecManager class to construct the maps that they save into the IM.  Specifically, they need to know to use those strings as keys in the Map<String, Object> to put the name and partType before they call add part.  In retrospect that was pretty bad, and I think I'm gonna have the editors instead pass those fields to the Controller along with a partial map, and have the Controller do that work.<br /><br />
	Feature – Tweak Settings: All the editor tabs allow you to tweak the settings of the part that they edit.  This is most applicable for the sprite editors.  By having the settings objects generated by annotations from the backend, the backend is able to specify whatever settings they'd like and the front end sprite editors will be able to accommodate it.  In this way, we never have to change the SpriteEditor or SpriteView code to allow new settings to be tweaked.  The only things necessary for tweaking a setting is the backend asking for that setting, and then a corresponding Setting object will be created in the SpriteEditor overlay and be able to be changed by the user.
	Feature – Setup Graphical Elements: this was done inside the map and sprite editors when they allowed the user to select image.  This was pretty simple, just loading an image from a file and storing it.  I then wrote code that would take the image and copy it into an ImageData folder inside the game so that even if the old image was deleted, the game would still have it.<br /><br />
	Feature – determine the order of advancement: Advancement order was handled by our round editor and wave editor UI's with our relative delay from t=0 format.  In some casual senses of the word, you could call rounds levels, and what we call levels a series of levels on the same map.  That's really a matter of semantics.  Since we didn't get to building a full game with multiple of what we called levels, what we have for order of advancement is seen in the round editor.  In the round editor, you specify, using those delays, which rounds come after which other rounds and how long of a wait there should be in between.  The round editor is not a very flexible class because most of its work was done so close to the end of the project that design was sacrificed for functionality.  For example, checking if a new map has the same paths as the last one was coded into that map display, making it impossible to reuse that display anywhere else.  <br /><br />
	
Alternate Designs<br /><br />
	Originally, we were going to create front end instances of all the objects but we decided not do that.  We felt that data flow between the editors was cleaner if we just passed data and not objects we created, and that passing around objects would be unnecessary.  We also originally had properties files that were used to generate the Settings objects in the SpriteViews, but Greg replaced that with annotations.  This was nice because it let the back end specify what it needed from the AE without having to write in the properties file.  <br /><br />
	The API changed often, but since we had relatively good communication throughout there wasn't very much confusion.  I made sure every time I changed a method I knew someone else needed I let them know the changes immediately and didn't merge anything into master that wasn't already totally up to date with the changes.  Some of the extraneous add methods in the controller are due to not wanting to change the API since it was already being used by the other editors, but I'll refactor those out in my masterpiece.<br /><br />
	One design decision we made was to have all the editors contain an instance of the controller.  This ended up working out pretty well.  It was easy for all the editors to get the data they needed when they needed it.  Originally we weren't really sure how to pass data around.  We toyed with the idea of making the Controller or InstanceManager contain static methods, but that would eliminate the possibility of having more than one game being authored at once, which we didn't want to do.  I prefer passing an instance of the Controller around.<br /><br />
	We also decided to have all references to other parts be done as keys into the larger map.  We could have also stored these references as file names, but storing file names just isn't that easy.  By storing them as keys, it provides a nice easy way for the editors to specify which other part a user chose.  For example, if the user is choosing between projectiles, whatever image he clicks on, just store the key that that image was generated from into the field for “projectile”.  This connection between what generated the display and what was stored back into whatever field was being updated is really why I like storing all references to other parts as keys.<br /><br />
	A third design decision was to store all the ImageData inside the game.  I like this because it makes sense for the image data to be stored with the actual game.  If it isn't, then the user could create a part, pick and image for it, but then not be able to find it again later if it was moved or deleted.  To minimize the size of the XML files, we had to store images as file paths.  In order to avoid storing absolute file paths, we stored file paths from the IM's root directory.   By doing this, and copying and saving the images into ImageData, we could avoid having huge things like 2D arrays of ints in our XML files that represented the individual parts and in the XML file that represents the IM, arrays which would have made the files themselves completely unreadable.  Due to constraints on the javafx Image object, it was difficult to re-instantiate an image, so the Controller provided a getImageForPart method with the roundabout code contained within it, so it didn't need to be written multiple times in the editors.<br /><br />
	One of the best features is our Controller.  It just does its job really well.  It provides the methods it needs to and gives every editor all the options it could possibly need for getting data, but only returns copies of that data so that no editor can actually alter data in any way without calling add part.  Another of the best features is the SpriteView and SpriteEditor setup.  This allows for any sprites to be added and edited easily.  The overlay is generated straight from the backend annotations giving them maximal flexibility in what they want to ask for, and also the UI for it looks good and is intuitive.<br /><br />
	The biggest issue right now is the player.  It's just not finished.  I already talked in depth about the time management, etc. that led to this being the case.  The second most important issue is loading.  We unfortunately didn't finish the UI support for loading things back into the AE, which is obviously a critical part of an AE.  Again, this was mostly just due to time management issues that I've discussed a lot.<br /><br />
	
